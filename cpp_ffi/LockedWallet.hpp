// Automatically generated by flapigen
#pragma once

//for assert
#include <cassert>
//for std::abort
#include <cstdlib>
//for std::move
#include <utility>
//for std::conditional
#include <type_traits>

#include "rust_str.h"
#include <string_view>
#include <stdint.h>
#include "CRustSliceu8.h"
#include "UnlockedWallet.hpp"
#include "c_UnlockedWallet.h"
#include "rust_result4232mut3232c_voidCRustString.h"
#include <variant>

#include "c_LockedWallet.h"

namespace rust {

template<bool>
class LockedWalletWrapper;
using LockedWallet = LockedWalletWrapper<true>;
using LockedWalletRef = LockedWalletWrapper<false>;


template<bool OWN_DATA>
class LockedWalletWrapper {
public:
    using value_type = LockedWalletWrapper<true>;
    friend class LockedWalletWrapper<true>;
    friend class LockedWalletWrapper<false>;

    using SelfType = typename std::conditional<OWN_DATA, LockedWalletOpaque *, const LockedWalletOpaque *>::type;
    using CForeignType = LockedWalletOpaque;

    LockedWalletWrapper(LockedWalletWrapper &&o) noexcept: self_(o.self_)
    {
        o.self_ = nullptr;
    }
    LockedWalletWrapper &operator=(LockedWalletWrapper &&o) noexcept
    {
        assert(this != &o);
        free_mem(this->self_);
        self_ = o.self_;
        o.self_ = nullptr;
        return *this;
    }
    explicit LockedWalletWrapper(SelfType o) noexcept: self_(o) {}
    LockedWalletOpaque *release() noexcept
    {
        LockedWalletOpaque *ret = self_;
        self_ = nullptr;
        return ret;
    }
    explicit operator SelfType() const noexcept { return self_; }
    LockedWalletWrapper<false> as_rref() const noexcept { return LockedWalletWrapper<false>{ self_ }; }
    const LockedWalletWrapper<true> &as_cref() const noexcept { return reinterpret_cast<const LockedWalletWrapper<true> &>(*this); }

    LockedWalletWrapper(const LockedWalletWrapper&) = delete;
    LockedWalletWrapper &operator=(const LockedWalletWrapper&) = delete;

    LockedWalletWrapper(std::string_view a0, RustSlice<const uint8_t> a1) noexcept
    {

        this->self_ = LockedWallet_new(CRustStrView{ a0.data(), a0.size() }, a1.as_c<CRustSliceu8>());
        if (this->self_ == nullptr) {
            std::abort();
        }
    }

    std::variant<UnlockedWallet, RustString> unlock(RustSlice<const uint8_t> a0) const noexcept;

private:
   static void free_mem(SelfType &p) noexcept
   {
        if (OWN_DATA && p != nullptr) {
            LockedWallet_delete(p);
        }
        p = nullptr;
   }
public:
    ~LockedWalletWrapper() noexcept
    {
        free_mem(this->self_);
    }

private:
    SelfType self_;
};


    template<bool OWN_DATA>
    inline std::variant<UnlockedWallet, RustString> LockedWalletWrapper<OWN_DATA>::unlock(RustSlice<const uint8_t> a0) const noexcept
    {

        struct CRustResult4232mut3232c_voidCRustString ret = LockedWallet_unlock(this->self_, a0.as_c<CRustSliceu8>());
        return ret.is_ok != 0 ?
              std::variant<UnlockedWallet, RustString> { UnlockedWallet(static_cast<UnlockedWalletOpaque *>(ret.data.ok)) } :
              std::variant<UnlockedWallet, RustString> { RustString{ret.data.err} };
    }

} // namespace rust
